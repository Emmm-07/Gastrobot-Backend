#include <ESP32Servo.h>
/* 
  Sketch generated by the Arduino IoT Cloud Thing "Untitled"
  https://create.arduino.cc/cloud/things/28ade428-abc5-47d9-9e9f-b27d536e584a 

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  String gas_Batt_IsEmpty_Obstacle;
  String logMessage;
  String videoUrl;
  float cameraPanHorizontal;
  float cameraPanVertical;
  float gasLevel;
  int batteryLevel;
  int botMovement;
  bool haveObstacle;
  bool haveObstacle_Front;
  bool isContainerEmpty;
  bool isSprayOn;
  bool isVacuumOn;
  bool isWifiConnected;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/

#include "thingProperties.h"

//For servo

  Servo myServoHorizontal;
  Servo myServoVertical;
  Servo servoSpray;
//For gas sensor SGP40
  #include <Wire.h>
  #include "Adafruit_SGP40.h"
  Adafruit_SGP40 sgp;
  VocAlgorithmParams vocParams;  
//For Weight Sensor HX711
  #include <HX711_ADC.h>
  #if defined(ESP8266)|| defined(ESP32) || defined(AVR)
  #include <EEPROM.h>
  #endif

  //PINS [available: 0(remove during boot), 12 (low during boot/startup), 34-39(Input only), 16 ]
  const int servoPinHorizontal = 23;
  const int servoPinVertical = 19;
  const int servoSprayPin = 18;
  int wheelsEna = 13;
  int wheelsPin1  = 14;
  int wheelsPin2 = 27;
  int wheelsPin3 = 26;
  int wheelsPin4  = 25;
  int wheelsEnb  = 33;
  int voltSensorPin = 34;
  int vacuumRelayPin = 32;

  //WeightSensor Pins
  int HX711_dout = 2; //mcu > HX711 dout pin, dont connect during boot
  int HX711_sck = 15; //mcu > HX711 sck pin

  // ultrasonic pins
  //(Back)
  #define TRIG_PIN 4  
  #define ECHO_PIN 5 
  //(Front)
  #define TRIG_PIN_F 17 
  #define ECHO_PIN_F 35 

 
  //For Weight sensor, HX711 constructor
  HX711_ADC LoadCell(HX711_dout, HX711_sck);
  const int calVal_eepromAdress = 0;
  unsigned long t = 0;

  //initializations
 int previousPanHorizontal=90;
 int previousPanVertical=90;
 int prevBotMovement = 0;
 float initialWeight =0;

// Task Handles
TaskHandle_t sensorTask1Handle = NULL;
TaskHandle_t sensorTask2Handle = NULL;   //Changed
TaskHandle_t cloudTaskHandle = NULL;

// Function prototypes for functions used in setup()
void gasSensorSetup();
void weightSensorSetup();
void sensorReadTask1(void *pvParameters);
void sensorReadTask2(void *pvParameters);
void cloudCommunicationTask(void *pvParameters);

void setup() {
  // Initialize serial and wait for port to open:
  Serial.begin(9600);
  // This delay gives the chance to wait for a Serial Monitor without blocking if none is found
  delay(1500); 
  Serial.println("In setup");
  // Defined in thingProperties.h
  initProperties();

  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);
  Serial.println("In ArduinoIoTPreferredConnection");
  /*
     The following function allows you to obtain more information
     related to the state of network and IoT Cloud connection and errors
     the higher number the more granular information you’ll get.
     The default is 0 (only errors).
     Maximum is 4
 */
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();
    Serial.println("In Debugging");

  //For Wheels
  pinMode(wheelsPin1, OUTPUT);
  pinMode(wheelsPin2, OUTPUT);
  pinMode(wheelsPin3, OUTPUT);
  pinMode(wheelsPin4, OUTPUT);
  //For Vacuum 
    Serial.println("In Wheels");
  pinMode(vacuumRelayPin, OUTPUT);
    Serial.println("In relays");
  //For Servo
  myServoHorizontal.setPeriodHertz(50);
  myServoVertical.setPeriodHertz(50);
  servoSpray.setPeriodHertz(50);
  bool servoAttached = servoSpray.attach(servoSprayPin, 500, 2400);
  bool verticalAttached = myServoVertical.attach(servoPinVertical, 500, 2400);
  bool horizontalAttached = myServoHorizontal.attach(servoPinHorizontal, 500, 2400);
   if (servoAttached && verticalAttached && horizontalAttached) {
    Serial.println("Servo successfully attached.");
  } else {
    Serial.println("Failed to attach servo.");
  }
    Serial.println("In srvo");
  //For Volt sensor
  analogSetAttenuation(ADC_11db); // Set the range to 0 to 3.3V for volt sensor
  pinMode(voltSensorPin, INPUT);
  delay(100);
    Serial.println("In volt");
  //For Ultrasonic 
  pinMode(TRIG_PIN, OUTPUT); 
  pinMode(ECHO_PIN, INPUT);
  pinMode(TRIG_PIN_F, OUTPUT); 
  pinMode(ECHO_PIN_F, INPUT);
  Serial.println("In Ultrasonics");

  // //For Gas sensor 

  gasSensorSetup();                 //Uncomment this if sgp40 is connected +++++++++++++++++++++++++++++++++++++++++
    // Serial.println("Gas Commented out");
    Serial.println("In Gas");

  //For weight sensor
  weightSensorSetup();              //Uncomment this if HX711 is connected +++++++++++++++++++++++++++++++++++++++++
    Serial.println("In weight");

   // Create tasks for FreeRTOS

    xTaskCreatePinnedToCore(sensorReadTask1, "SensorTask1", 10000, NULL, 1, &sensorTask1Handle, 1);
      Serial.println("In Sensor Task 1");
    xTaskCreatePinnedToCore(sensorReadTask2, "SensorTask2", 10000, NULL, 1, &sensorTask2Handle, 1);   //Changed
      Serial.println("In Sensor Task 2");                                                                              
    xTaskCreatePinnedToCore(cloudCommunicationTask, "CloudTask", 12000, NULL, 2, &cloudTaskHandle, 0); // Highest priority
      Serial.println("In Cloud Task");
} // <-- Added missing closing brace for setup()

//---------------------------------------LOOP----------------------------------
void loop() {
  // Your code here 
  
}
//------------------------------SET-----------------------------------------------------

/*
  Since BatteryLevel is READ_WRITE variable, onBatteryLevelChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onBatteryLevelChange()  {
  // Add your code here to act upon BatteryLevel change
}
/*
  Since IsContainerEmpty is READ_WRITE variable, onIsContainerEmptyChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onIsContainerEmptyChange()  {
  // Add your code here to act upon IsContainerEmpty change
}
/*
  Since GasLevel is READ_WRITE variable, onGasLevelChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onGasLevelChange()  {
  // Add your code here to act upon GasLevel change
}

/*
  Since LogMessage is READ_WRITE variable, onLogMessageChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onLogMessageChange()  {
  // Add your code here to act upon LogMessage change
}

/*
  Since IsWifiConnected is READ_WRITE variable, onIsWifiConnectedChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onIsWifiConnectedChange()  {
  // Add your code here to act upon IsWifiConnected change
}

//-------------------------------GET-------------------------------------------
/*
  Since IsSprayOn is READ_WRITE variable, onIsSprayOnChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onIsSprayOnChange()  {
  // Add your code here to act upon IsSprayOn change
   setLogMessage("isSprayOn: " + String(isSprayOn));
    Serial.println("isSprayOn: " + String(isSprayOn));
  if(isSprayOn){
      servoSpray.write(100);
      // setLogMessage("100 deg");
  }else{
      servoSpray.write(0);
      // setLogMessage("0 deg");
  }
  // setLogMessage("done spray");
}

/*
  Since BotMovement is READ_WRITE variable, onBotMovementChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onBotMovementChange()  {
  // Add your code here to act upon BotMovement change
  setLogMessage("botMovement: " + String(botMovement));
  if(prevBotMovement != botMovement){
      if(botMovement == 0){
          stopBot();
      }else if (botMovement == 1){
          goForward();
      }else if(botMovement == 2){             
          goRight();
      }else if(botMovement == 3){            
        goBackward();
      }else if(botMovement == 4){            
          goLeft();
      }
  }
  prevBotMovement = botMovement;
}

/*
  Since CameraPanHorizontal is READ_WRITE variable, onCameraPanHorizontalChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onCameraPanHorizontalChange()  {
  // Add your code here to act upon CameraPanHorizontal change
  setLogMessage("camera horizontal: " + String(cameraPanHorizontal));
  Serial.println("camera horizontal: " + String(cameraPanHorizontal));
  if(cameraPanHorizontal!=previousPanHorizontal){
      myServoHorizontal.write(cameraPanHorizontal);
      previousPanHorizontal = cameraPanHorizontal;
  }
}

/*
  Since CameraPanVertical is READ_WRITE variable, onCameraPanVerticalChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onCameraPanVerticalChange()  {
  // Add your code here to act upon CameraPanVertical change
  setLogMessage("camera vertical: " + String(cameraPanVertical));
  Serial.println("camera vertical: " + String(cameraPanVertical));
  if(cameraPanVertical!=previousPanVertical){
      myServoVertical.write(cameraPanVertical);
      previousPanVertical = cameraPanVertical;
  }
}


/*
  Since IsVacuumOn is READ_WRITE variable, onIsVacuumOnChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onIsVacuumOnChange()  {
  // Add your code here to act upon IsVacuumOn change
   setLogMessage("isVacuumOn: " + String(isVacuumOn));
  if(isVacuumOn){
    digitalWrite(vacuumRelayPin, HIGH);
  }else{
     digitalWrite(vacuumRelayPin, LOW);
  }
 
}


/*
  Since GasBattIsEmpty is READ_WRITE variable, onGasBattIsEmptyChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onGasBattIsEmptyChange()  {
  // Add your code here to act upon GasBattIsEmpty change
}

/*
  Since GasBattIsEmptyObstacle is READ_WRITE variable, onGasBattIsEmptyObstacleChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onGasBattIsEmptyObstacleChange()  {
  // Add your code here to act upon GasBattIsEmptyObstacle change
}


//---------------------------------------------FUNCTIONS---------
void stopBot(){
    setLogMessage("Stopping");
    analogWrite(wheelsEna, 0);
    analogWrite(wheelsEnb, 0);
    digitalWrite(wheelsPin1, LOW);
    digitalWrite(wheelsPin2, LOW);
    digitalWrite(wheelsPin3, LOW);
    digitalWrite(wheelsPin4, LOW);
    // delay(200);
    
}
void goForward(){
    // stopBot();
    setLogMessage("Forwarding");
    analogWrite(wheelsEna, 150);
    analogWrite(wheelsEnb, 150);
    digitalWrite(wheelsPin1, HIGH);
    digitalWrite(wheelsPin2, LOW);
    digitalWrite(wheelsPin3, LOW);
    digitalWrite(wheelsPin4, HIGH);
      
}
void goRight(){
    // stopBot();
    setLogMessage("Going Right");
    analogWrite(wheelsEna, 180);
    analogWrite(wheelsEnb, 180);
    digitalWrite(wheelsPin1, LOW);
    digitalWrite(wheelsPin2, HIGH);
    digitalWrite(wheelsPin3, LOW);
    digitalWrite(wheelsPin4, HIGH);    
}
void goBackward(){
    // stopBot();
    setLogMessage("Backwarding");
    analogWrite(wheelsEna, 150);
    analogWrite(wheelsEnb, 150);
    digitalWrite(wheelsPin1, LOW);
    digitalWrite(wheelsPin2, HIGH);
    digitalWrite(wheelsPin3, HIGH);
    digitalWrite(wheelsPin4, LOW); 
}
void goLeft(){
    // stopBot();
    setLogMessage("Going Left");
    analogWrite(wheelsEna, 180);
    analogWrite(wheelsEnb, 180);
    digitalWrite(wheelsPin1, HIGH);
    digitalWrite(wheelsPin2, LOW);
    digitalWrite(wheelsPin3, HIGH);
    digitalWrite(wheelsPin4, LOW);   
}

// Volt sensor value -----------------------------
int readVoltValue() {
    String message = "in readVoltValue()\n";
   
      int value = analogRead(voltSensorPin); // Get the ADC reading (0-4095)
    // Convert the analog reading to voltage (0-3.3V)
    double voltage = value * (3.3 / 4095.0);
    message+="Measured Voltage before factor: " + String(voltage);

    float high = 2.11;
    float low = 1.7391;
    int volt_percent = (int)(((voltage - low) / (high - low)) * 100);
    // If using a voltage divider, calculate the original input voltage.
    // Assuming a 33kΩ and 4.7kΩ divider:
    double inputVoltage = voltage * ((33.0 + 4.7) / 4.7);

   
    message+="\nMeasured Voltage after factor: " + String(voltage); // Print the scaled voltage
    message+="\nCalculated Orign " + String(inputVoltage); // Print the calculated original input voltage
    message+="\nvolt percent %: " + String(volt_percent);
    setLogMessage(message);
    return volt_percent;
 }

 // Gas Sensor Value ------------------------------------------
int readGasValue(){
      // Get the raw VOC reading from SGP40
    uint16_t voc_raw = sgp.measureRaw();
    // Variable to hold the calculated VOC index
    int32_t voc_index = 0;
    // Process the raw sensor value to get the VOC index using the algorithm
    VocAlgorithm_process(&vocParams, voc_raw, &voc_index);
    // Print the raw and calculated VOC index values
    setLogMessage("Raw VOC Reading: "+String(voc_raw)+
                "\nVOC Index (ppb): " + String(voc_index));

    // Serial.println("Raw VOC Reading: "+String(voc_raw)+
    //             "\nVOC Index (ppb): " + String(voc_index));

    return int(voc_index);
}


// Weight sensor value -------------------------------------
  bool readWeightValue(){
  while (!LoadCell.update()) {
     delay(10); 
  }
  // get smoothed value from the dataset:
  float calibFactor = 76.5 / 185.0; // calibration factor based on weighing scale, 76.5 g 
  float i = LoadCell.getData();
  // String message = "Load_cell output val original: " + String(i);

  i=(i*-1) - 5.5;       //5.5 can be changed for calibration
  // message+="\nLoad_cell output val calibrated: " + String(i);
  

  // check if last tare operation is complete:
  // if (LoadCell.getTareStatus() == true) {
  //   setLogMessage("Tare complete");
  // }
  i = abs(initialWeight - i);
  i *= calibFactor; 
  String message = "\nWeight Final Output: " + String(i) + "\n";

  setLogMessage(message);
  float threshold = 105.0; 
  if(i<threshold ){
    return true;
  }else{
    return false;
  }

}

  // Obstacle sensor value -------------------------------------
  // Rear readObstacle Ultrasonic
  bool readObstacleValue(){
      long duration, distance_cm;

      // Clear the TRIG_PIN
      digitalWrite(TRIG_PIN, LOW);
      delayMicroseconds(2);
      // Send a 10 microsecond pulse to TRIG_PIN
      digitalWrite(TRIG_PIN, HIGH);
      delayMicroseconds(10);
      digitalWrite(TRIG_PIN, LOW);

      // Read the pulse from ECHO_PIN
      duration = pulseIn(ECHO_PIN, HIGH);
      //  Serial.println("Distance (raw): "+ String(duration));
      // Calculate the distance in centimeters
      distance_cm = duration * 0.034 / 2;

      // Print the result to the serial monitor
      setLogMessage("Rear Distance (cm): "+ String(distance_cm));
      // Serial.println("Distance (cm): "+ String(distance_cm));
      // Serial.println("Distance (calibrated): "+ String(distance_cm-9));
      // Serial.println("Distance (cm): "+ String(distance_cm));

      if (distance_cm <= 50){
            stopBot();                    // Edited / Chaneg / Added
          return true;
      }else{
          return false;
      }
      
  }
 // Front readObstacle Ultrasonic
 bool readObstacleFrontValue(){
      long duration, distance_cm;
      // Clear the TRIG_PIN
      digitalWrite(TRIG_PIN_F, LOW);
      delayMicroseconds(2);
      // Send a 10 microsecond pulse to TRIG_PIN
      digitalWrite(TRIG_PIN_F, HIGH);
      delayMicroseconds(10);
      digitalWrite(TRIG_PIN_F, LOW);

      // Read the pulse from ECHO_PIN
      duration = pulseIn(ECHO_PIN_F, HIGH);
      // Calculate the distance in centimeters
      distance_cm = duration * 0.034 / 2;
      // Print the result to the serial monitor
      setLogMessage("Front Distance (cm): "+ String(distance_cm));

      if (distance_cm <= 50){
            stopBot();                    // Edited / Chaneg / Added
          return true;
      }else{
          return false;
      }
      
  }
  void setLogMessage(String message){
    logMessage = message;
  }





//------------------SETUPS------------------------
  void gasSensorSetup(){
    while(!sgp.begin()) {       
      Serial.println("Failed to find SGP40 chip");                        
      setLogMessage("Failed to find SGP40 chip");
      
    }
    delay(100);
    VocAlgorithm_init(&vocParams);
    VocAlgorithm_set_tuning_parameters(&vocParams, 
                                          1.0,         // voc_index_offset      100 
                                          12.0,         // learning_time_hours
                                          180.0,        // gating_max_duration_minutes
                                          30.0);        // std_initial    50
    // setLogMessage("SGP40 Found and VOC Algorithm Initialized!");
    
  }

  void weightSensorSetup(){
    LoadCell.begin();
    float calibrationValue = 696.0; // calibration value (see example file "Calibration.ino")
    #if defined(ESP8266)|| defined(ESP32)
      // EEPROM.begin(512); // uncomment this if you use ESP8266/ESP32 and want to fetch the calibration value from eeprom
    #endif
      EEPROM.get(calVal_eepromAdress, calibrationValue); // uncomment this if you want to fetch the calibration value from eeprom
    unsigned long stabilizingtime = 2000; // preciscion right after power-up can be improved by adding a few seconds of stabilizing time
    bool _tare = true; //set this to false if you don't want tare to be performed in the next step
    LoadCell.start(stabilizingtime, _tare);
    if (LoadCell.getTareTimeoutFlag()) {
      setLogMessage("Timeout, check MCU>HX711 wiring and pin designations");
      while (1);
    }
    else {
      LoadCell.setCalFactor(calibrationValue); // set calibration value (float)
      setLogMessage("Startup is complete");
    }

    //servo horizontal and vertical initialize
    myServoHorizontal.write(100);
    myServoVertical.write(100);

    //Initialize initial Weight
    delay(2000);                              //Changed
        while (!LoadCell.update()) {
        delay(10); 
      } 
    float i = LoadCell.getData();
    i=(i*-1) - 5.5;       //5.5 can be changed for calibration
    initialWeight = i;        //Changed
  }





// Define TASKS --------------------------------------------------------

// Function to handle cloud communication
void cloudCommunicationTask(void *pvParameters) {
    while (true) {
        // Update the Arduino Cloud
        ArduinoCloud.update();
         if (ArduinoCloud.connected()) {
            isWifiConnected = !isWifiConnected;
        }else{
        // go to initial state if disconnected to wifi
            servoSpray.write(0);
            stopBot();
            digitalWrite(vacuumRelayPin, LOW);
            myServoHorizontal.write(100);
            myServoVertical.write(100);
        }

        

        // Delay for a short time to allow other tasks to run
        // This can be adjusted; a short delay keeps the loop responsive
        vTaskDelay(10 / portTICK_PERIOD_MS);  // Adjust based on your needs
    }
}

// Function to read sensor data
void sensorReadTask1(void *pvParameters) {
    while (true) {
        // Read sensor data
        // Delay for a while (e.g., 500ms)
  
        haveObstacle = readObstacleValue();
        haveObstacle_Front = readObstacleFrontValue();
        isContainerEmpty=readWeightValue();

        gas_Batt_IsEmpty_Obstacle = "{\"gas\":" + String(gasLevel) + ",\"batt\":" + String(batteryLevel) + ",\"container\":" + String(isContainerEmpty) + ",\"obstacle\":" +String(haveObstacle) + ",\"obstacleFront\":" + String(haveObstacle_Front) + ",\"isWifiConnected\":" + String(isWifiConnected) +"}"; //Changed

        vTaskDelay(800 / portTICK_PERIOD_MS);
    }
}
void sensorReadTask2(void *pvParameters) {
    while (true) {
        // Read sensor data
        // Delay for a while (e.g., 500ms)
        batteryLevel = readVoltValue();
        gasLevel=readGasValue();                 ///Uncomment, Test these individually +++++++++++++++++++++++++++++++++++++++++
        // Serial.println("readGasValue Comented out");
      
        gas_Batt_IsEmpty_Obstacle = "{\"gas\":" + String(gasLevel) + ",\"batt\":" + String(batteryLevel) + ",\"container\":" + String(isContainerEmpty) + ",\"obstacle\":" +String(haveObstacle) + ",\"obstacleFront\":" + String(haveObstacle_Front) +  ",\"isWifiConnected\":" + String(isWifiConnected) +"}"; //Changed

        vTaskDelay(1200 / portTICK_PERIOD_MS);
    }
}


/*
  Since HaveObstacle is READ_WRITE variable, onHaveObstacleChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onHaveObstacleChange()  {
  // Add your code here to act upon HaveObstacle change
}

/*
  Since VideoUrl is READ_WRITE variable, onVideoUrlChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onVideoUrlChange()  {
  // Add your code here to act upon VideoUrl change
}

/*
  Since HaveObstacleFront is READ_WRITE variable, onHaveObstacleFrontChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onHaveObstacleFrontChange()  {
  // Add your code here to act upon HaveObstacleFront change
}
